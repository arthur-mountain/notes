# Compiler 與效能核心理解指南

本篇整理了從語言自舉(Bootstrapping)、編譯器依賴、效能關鍵、到系統呼叫(syscall)的全脈絡觀念，適合作為學習 Compiler 主題的起點。

---

## 🧬 語言自舉與編譯器演化

1. **編譯器的最初版本** 都是用組合語言或 C/C++ 手寫出來的。

2. 隨後會用該語言**重寫自己的編譯器**，稱為 **bootstrapping(自舉)**。

3. 現代語言如 Go、Rust、Swift：

   - 初代編譯器是用 C/C++ 或 OCaml 寫的；

   - 之後改用自己語言實作自己；

   - 最終能脫離原語言、完全自我編譯。

---

## 🧱 自舉 ≠ 完全獨立

即使語言能自我編譯，**仍然高度依賴底層工具鏈**：

- C/C++ 編譯器(如 clang、gcc)

- LLVM IR 與後端最佳化工具

- libc 等標準函式庫

- as、ld(組譯器與連結器)

🧩 當這些底層工具或作業系統 ABI 變更時，語言的編譯流程也需調整。

---

## ⚙️ 編譯流程總覽(流程圖)

```mermaid
graph TD
    A[原始碼(source code)] --> B[前端編譯器(語法分析 / AST)]
    B --> C[中間表示(IR / HIR / MIR / SSA)]
    C --> D[最佳化(Inlining, Loop unrolling, etc)]
    D --> E[機器碼產生(codegen)]
    E --> F[可執行檔 or Object File]
```

- 編譯器將高階語言轉換為機器能理解的 native code。

- **IR** 是中介層，有利於語言無關的優化(例如透過 LLVM)。

---

## 🚀 為何 Go / Rust 能接近甚至超越 C 效能？

因為它們的編譯器具備以下特性：

| 層面               | 關鍵說明                                   |
| ------------------ | ------------------------------------------ |
| 📦 輸出品質        | Native Machine Code，品質與 C 一樣甚至更優 |
| 🎯 無 runtime 負擔 | Rust 無 GC / VM，Go 有 GC 但設計優良       |
| 🧠 編譯器最佳化    | 採用 LLVM、SSA 等架構，可深入最佳化        |
| 🧵 併發能力        | 語言內建支援多核 CPU 的並發機制            |

🧵 **Zero-cost abstraction(零成本抽象)** 是 Rust 成功的核心：
抽象不等於效能損失，只要編譯器夠聰明，就能生成一樣快的機器碼。

---

## 🔍 編譯器最佳化的實際例子

| 優化技術              | 敘述                           |
| --------------------- | ------------------------------ |
| Inlining              | 把函數展開，減少呼叫開銷       |
| Constant Folding      | 預先計算常數值，減少執行時運算 |
| Dead Code Elimination | 移除不會執行的程式碼           |
| Loop Unrolling        | 減少迴圈控制成本，提升效率     |
| SIMD 指令             | 平行加速數值運算               |

---

## 🧾 系統呼叫(Syscall)的真相

以 `open()` 為例，它本身不是系統呼叫，而是 **libc 提供的包裝函式**。

流程如下：

```mermaid
graph TD
    U[User Code: open()] --> L[libc: 包裝參數與 syscall 編號]
    L --> S[syscall 指令]
    S --> K[Kernel: 實際處理請求]
    K --> R[回傳結果]
```

- 實際發出「系統呼叫」的是一條特殊的 `syscall` 指令，觸發 CPU 進入 kernel mode。

- 開檔、讀寫等操作是由作業系統核心負責，非 user space 執行。

---

## ✅ 最核心的結論

> **中間有幾層編譯器不重要，重點是最終產出的機器碼品質。**

編譯器的語言實作方式不影響最終效能，**只要產出的 Native Code 有效率，程式就能跑得非常快。**

Go 和 Rust 的成功證明了這一點：

- 高階抽象 + 最佳化 IR 架構 + native code 輸出 = 強效能與好開發體驗並存。

---

## 🎯 延伸學習(建議練習方向)

想更進一步學習 Compiler，可從以下方向實作：

- 小型語言的詞法/語法分析器(使用 ANTLR 或手刻)

- LLVM IR 編寫與優化實驗(手動寫 SSA、試著加入簡單優化 Pass)

- 製作直譯器(interpreter)與簡單虛擬機(VM)

- 撰寫 C / Rust 原始碼並觀察產出的 Assembly / IR 比較效能
