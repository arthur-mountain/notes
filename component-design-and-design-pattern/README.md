# Component 與資料處理的責任分工：封裝 vs 控制的設計抉擇

## ✳️ 前言

在開發 UI component 的過程中，常常會遇到一個抉擇：

- **資料應該在 component 外處理好，還是由 component 自己處理？**

這不只是技術細節的選擇，而是牽涉到封裝、可維護性、可測試性、與使用者體驗等多方面的設計考量。

先從前端 component 的實際開發經驗出發，接著延伸探討這個問題在整體軟體設計上的普遍性。

## 📦 Component 與資料處理：兩種常見設計方式

### 方式一：資料先處理，照著 component 規則走（外部轉換）

- Component 視為 UI 呈現單位，不負責處理資料，只接受格式化後的 props。
- 這種模式下 component 類似一個 [Facade pattern](https://refactoring.guru/design-patterns/facade)：對外暴露清晰介面，背後邏輯簡單可控。

**特色：**

- Component interface（即 props type definition）非常清楚。
- 外部必須先將資料轉換成符合格式才能使用。
- Component 本身簡潔明瞭，接近 Pure UI Component。

**優點：**

- 分工清楚，責任單一。
- 容易測試（因為純粹）。
- 只要符合介面規則，就能保證行為穩定。
- 適合開源 component / library 等需要通用性的設計。

**缺點：**

- 每次使用前都需要處理資料，若跨 repo 無法共用轉換邏輯，會導致重複實作。
- 對使用者來說比較「麻煩」，需要理解 component 的規則與資料格式。

---

### 方式二：component 內部自行轉換資料（封裝轉換）

- 將原始資料直接丟入 component，由 component 自行轉換資料格式。
- 這種模式類似 [Adapter pattern](https://refactoring.guru/design-patterns/adapter)：component 內部實作 adapter function，轉換成自己需要的資料結構。

**特色：**

- 使用者不需要處理資料，component 自行包裝。
- 對外提供更好的易用性，但責任較多。

**優點：**

- 減少重複的資料轉換邏輯。
- 跨 repo 使用時更方便，不需要另外實作轉換。
- 即使 component 封裝邏輯，通常仍然易於測試。

**缺點：**

- component 內部變得「不純粹」，不再只是 UI。
- 封裝了過多邏輯，可能造成使用者不了解底層行為。
- 當接收多種格式資料時，需實作 switch case / variant adapter。

## 🧠 為什麼我最初用的是第一種，但覺得第二種比較好？

一開始我採用的是方式一，也比較符合我對 clean architecture 的習慣。不過，在多次專案實作中我發現：

> **當 component 實作 adapter function 後，程式整體反而更簡潔了。**

即使 component 不再是純粹的 UI 呈現，但多數情況下這樣的封裝讓實際使用更流暢、也容易維護。尤其在單元測試依然容易撰寫的前提下，這種設計就非常合理。

那為什麼業界還是常見第一種方式？

原因在於以下幾點：

1. **開源套件 / 通用組件** 通常希望維持「介面穩定」，讓使用者能夠清楚知道怎麼操作。
2. Component 使用者越多、來源越雜，**內部封裝資料轉換會降低可控性與穩定性**。
3. 資料轉換在外層可以更靈活擴充，也容易套用單一責任原則（Single Responsibility Principle）。

> 如果可以將資料轉換邏輯抽成可共用的 util，兩種方式其實就能達成一致的效果。

## 🧩 延伸：這樣的問題其實存在於整個軟體開發中

其實這樣的設計抉擇，不只出現在 UI component 上，也大量出現在軟體架構的各個層級。這種「**資料應該在哪裡處理？責任應該放哪裡？**」的問題，本質是：

> **封裝（Encapsulation）與控制（Control）之間的取捨。**

以下是幾個常見場景：

### 1. SDK / API 設計

- SDK 封裝所有細節，讓使用者只要「無腦丟資料」就能運作。
- REST API 要求 payload 結構固定，使用者需要自行處理資料格式。

### 2. Microservice 資料交換

- 使用 Protobuf / JSON schema 明確定義 service 之間資料格式 → 責任清楚
- 使用 Gateway + Transformer 統一處理 messy input → 彈性高但黑箱感重

### 3. 後端 API 設計

- 使用 BFF（Backend For Frontend）幫前端轉資料 → 提高開發效率
- 或要求前端根據後端傳回的 domain object 自行處理資料 → 適合架構穩定的系統

### 4. Form / 元件封裝

- Ant Design、MUI 等要求你傳入格式化後的值 → 清楚但不夠方便
- 其他 UI 套件可能會自動解析日期、金額、單位等 → 封裝度高但可控性低

## 🏢 業界是怎麼做的？

| 原則                                | 說明                                                           |
| ----------------------------------- | -------------------------------------------------------------- |
| ✅ **Interface 穩定性**             | 一旦定義對外介面就不輕易改動，保持向下相容                     |
| ✅ **責任清楚**                     | 拆分邊界明確的責任，例如 adapter、normalizer layer             |
| ✅ **封裝只是包邊界，核心保持純粹** | messy 處理放邊界層，中間邏輯盡量保持乾淨                       |
| ✅ **根據使用對象來決定封裝程度**   | 給外部用 → 強封裝；給內部用 → 控制優先                         |
| ✅ **多層次處理策略**               | 例如 GraphQL + Resolver + Adapter → 分散責任，彈性處理資料轉換 |

## 📌 我們可以怎麼選擇？

問自己幾個問題，就能幫助你決定使用方式一還是方式二：

| 問題                   | 偏向                                |
| ---------------------- | ----------------------------------- |
| 是否給內部自己人用？   | 是 → 可封裝（方式二）               |
| 是否需要跨 repo 使用？ | 是 → 應明確定義 interface（方式一） |
| 是否重視測試與重用性？ | 是 → 保持 component 純粹（方式一）  |
| 是否資料來源很雜？     | 是 → 封裝轉換更有效（方式二）       |

> 記住：**把混亂留在邊界，把純粹留在核心**。
> messy input 處理應放在邊界層（adapter、resolver、parser），保護核心 component 或邏輯的純粹與可測試性。

## ✅ 結語

- 不同的專案、不同的團隊階段、不同的使用場景，都會導致選擇不同設計方式。

- 無論是哪種設計，都建議先明確「責任歸屬」，再考慮使用體驗或封裝程度。

- 最重要的是保持**一致性、可維護性與清晰的邊界設計**。
